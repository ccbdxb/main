<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mazement Test Minting</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; background:#0b0c10; color:#eaf5ff; }
    .wrap { max-width: 1300px; margin: 40px auto; padding: 24px; background:#11141a; border:1px solid #222936; border-radius:16px; }
    h1 { margin:0 0 8px; }
    .row { display:flex; justify-content:space-between; padding:10px 12px; background:#0e1218; border:1px solid #1d2431; border-radius:10px; margin-top:10px; }
    .stack{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .grid{ display:grid; gap:10px; grid-template-columns: 1fr 1fr; }
    button{ cursor:pointer; padding:10px 14px; border-radius:10px; border:1px solid #2a3344; background:#1f2837; color:#eaf5ff; }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    input[type=text], input[type=number], textarea{
      width:100%; padding:10px 12px; border-radius:10px; border:1px solid #2a3344; background:#0e1218; color:#eaf5ff;
    }
    label{ font-size:14px; opacity:.9 }
    a{ color:#8ab4ff; }
    .muted{ opacity:.8 }
    .error{ color:#ff6b6b }
    .ok{ color:#6bff95 }
    .pill{ font-size:12px; padding:4px 8px; border-radius:999px; background:#1b2230; border:1px solid #2a3344; }
    .kvs{ display:flex; gap:12px; align-items:center; flex-wrap:wrap}
    .kvs span{ font-size:12px; opacity:.9; }
    .panel{ padding:12px; border:1px solid #1d2431; border-radius:12px; background:#0e1218; }
    .divider{ height:1px; background:#1d2431; margin:14px 0; }
    .tiny{ font-size:12px; opacity:.85 }
    .links a{ display:block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js" defer></script>
</head>
  <style>
  .layout{display:grid;grid-template-columns:minmax(240px,340px) 1fr;gap:24px;align-items:start}
  .art{background:#fff;border:1px solid #1d2431;border-radius:12px;padding:10px}
  .art img{display:block;width:100%;height:auto}
  .caption{font-size:12px;opacity:.8;margin-top:8px;text-align:center;color:#000;}
  @media (max-width:860px){.layout{grid-template-columns:1fr}}
 </style>
<body>
  <div class="wrap">
    <div class="layout">
    <!-- Left: maze image -->
    <aside class="art">
      <!-- put the actual filename below; path is relative to index.html -->
      <img src="images/mazement_preview.png" alt="Mazement preview"
           width="640" height="640" loading="eager" decoding="async" />
      <div class="caption">Mazement preview</div>
    </aside>
    <h1>Owner Mint</h1>
    <div class="kvs">
      <span>Network: <strong id="network">—</strong></span>
      <span>Contract: <a id="contractLink" href="#" target="_blank" rel="noreferrer">—</a></span>
      <span>Name/Symbol: <strong id="ns">—</strong></span>
    </div>

    <!-- Wallet controls -->
    <div class="stack" style="margin:12px 0 16px;">
      <button id="connectAuto">Connect (Auto)</button>
      <button id="connectBrave">Connect with Brave</button>
      <button id="connectMM">Connect with MetaMask</button>
      <button id="connectLegacy">Force Connect (Legacy)</button>
      <button id="testEmail">Test Email</button>
      <button id="switchBtn" style="display:none;">Switch to Polygon</button>
      <span id="address" class="pill">Not connected</span>
    </div>

    <div class="row"><span>Supply</span><strong><span id="supply">—</span>/<span id="max">—</span> (<span id="left">—</span> left)</strong></div>
    <div class="row"><span>Price</span>
      <strong>
        <span id="priceMatic">—</span>
        <span class="tiny">/ <span id="priceUsd">—</span></span>
      </strong>
    </div>

    <!-- Mint panel -->
    <div class="panel" style="margin-top:12px;">
      <div class="muted" style="margin-bottom:8px;">Recipient address (single) or multiple (comma, space, or newline-separated)</div>
      <textarea id="to" rows="3" placeholder="0x... or paste addr1, addr2, addr3..."></textarea>

      <div class="grid" style="margin-top:10px;">
        <div class="col">
          <label><input type="checkbox" id="claimNow" /> Claim physical now (in the same tx)</label>
          <div class="tiny muted">If enabled, we’ll hash the shipping info below and pass it to <code>mintFor</code>.</div>
        </div>
        <div class="col">
          <label for="shipping">Shipping info (free text, will be hashed to bytes32)</label>
          <input id="shipping" type="text" placeholder="Name, email, delivery address..."/>
        </div>
      </div>

      <div class="stack" style="margin-top:12px;">
        <button id="mintMeBtn" disabled>Mint to me</button>
        <button id="mintBtn" disabled>Mint to address(es)</button>
      </div>
      <div class="tiny muted" style="margin-top:6px;">
        Each mint calls <code>mintFor(to, claimNow, shippingInfoHash)</code> and sends <code>requiredWei()</code> as <code>msg.value</code>.
      </div>
    </div>

    <p id="status" class="muted" style="min-height:22px; margin-top:14px;"></p>
    <div id="link" class="links" style="min-height:22px;"></div>

    <div class="divider"></div>

    <!-- Owner tools -->
    <h3 style="margin:0 0 8px;">Owner Tools — Physical Delivery</h3>
    <div class="panel">
      <div class="grid">
        <div class="col">
          <label for="checkId">Token ID</label>
          <input id="checkId" type="number" min="1" placeholder="eg. 1" />
          <div class="stack">
            <button id="btnCheck">Check Status</button>
          </div>
          <div class="tiny" style="margin-top:8px;">
            Claimed: <strong id="claimedOut">—</strong> &nbsp; Delivered: <strong id="deliveredOut">—</strong>
          </div>
        </div>
        <div class="col">
          <label>Set Delivered</label>
          <div class="stack">
            <button id="btnSetDeliveredTrue" disabled>Set Delivered = true</button>
            <button id="btnSetDeliveredFalse" disabled>Set Delivered = false</button>
          </div>
          <div class="tiny" style="margin-top:8px;">
            claimOpen: <strong id="claimOpen">—</strong> &nbsp; deliveryUpdatesOpen: <strong id="deliveryOpen">—</strong>
          </div>
        </div>
      </div>
    </div>

  </div>

  <script defer>
    // ====== CONTRACT CONFIG ======
    const RAW_CONTRACT_ADDRESS = "0x20e28b37f331c9d94f1685f5fa1d1fc6d59d69b6"; // your address
    const ABI = [
      {"type":"function","name":"totalMinted","stateMutability":"view","inputs":[],"outputs":[{"type":"uint256"}]},
      {"type":"function","name":"MAX_SUPPLY","stateMutability":"view","inputs":[],"outputs":[{"type":"uint256"}]},
      {"type":"function","name":"remaining","stateMutability":"view","inputs":[],"outputs":[{"type":"uint256"}]},
      {"type":"function","name":"owner","stateMutability":"view","inputs":[],"outputs":[{"type":"address"}]},
      {"type":"function","name":"name","stateMutability":"view","inputs":[],"outputs":[{"type":"string"}]},
      {"type":"function","name":"symbol","stateMutability":"view","inputs":[],"outputs":[{"type":"string"}]},
      {"type":"function","name":"requiredWei","stateMutability":"view","inputs":[],"outputs":[{"type":"uint256"}]},
      {"type":"function","name":"mintPriceUsdCents","stateMutability":"view","inputs":[],"outputs":[{"type":"uint256"}]},
      {"type":"function","name":"claimOpen","stateMutability":"view","inputs":[],"outputs":[{"type":"bool"}]},
      {"type":"function","name":"deliveryUpdatesOpen","stateMutability":"view","inputs":[],"outputs":[{"type":"bool"}]},
      {"type":"function","name":"physicalClaimed","stateMutability":"view","inputs":[{"type":"uint256"}],"outputs":[{"type":"bool"}]},
      {"type":"function","name":"physicalDelivered","stateMutability":"view","inputs":[{"type":"uint256"}],"outputs":[{"type":"bool"}]},
      {"type":"function","name":"setDelivered","stateMutability":"nonpayable","inputs":[{"type":"uint256","name":"tokenId"},{"type":"bool","name":"delivered"}],"outputs":[]},
      {"type":"function","name":"mintFor","stateMutability":"payable","inputs":[{"name":"to","type":"address"},{"name":"claimNow","type":"bool"},{"name":"shippingInfoHash","type":"bytes32"}],"outputs":[]},
    ];

    // --- Email webhook (Google Apps Script Web App URL) ---
    const EMAIL_WEBHOOK_URL = "https://script.google.com/macros/s/AKfycbz_FeczSgjnUyIKUmi5PinPuyjc9g4bh9lhafeX2Z1r9hK-jeseMPaB9hFGUk4Bp-4eSA/exec";

    /**
     * Sends the mint + shipping details to your email via Apps Script.
     * Shows success/failure on the page status line and logs details to the console.
     */
    // Replace your existing sendClaimEmail with this version.
    async function sendClaimEmail({ wallet, tokenId, txHash, claimNow, shippingText, shippingHash }) {
      if (!EMAIL_WEBHOOK_URL) {
        setStatus("Email not configured (EMAIL_WEBHOOK_URL is empty).", "error");
        return;
      }
    const payload = {
      wallet, tokenId, txHash, claimNow: !!claimNow,
      shippingText: shippingText || "",
      shippingHash: shippingHash || "",
      timestamp: new Date().toISOString(),
      schema: "v1"
    };

    // 1) Try a simple CORS-friendly POST (no preflight) using text/plain.
    try {
      const res = await fetch(EMAIL_WEBHOOK_URL, {
        method: "POST",
        // Important: text/plain avoids the OPTIONS preflight that Apps Script often chokes on.
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify(payload)
      });
      // If the server doesn’t return proper CORS headers, the fetch may still succeed but be unreadable.
      // If we got here without throwing, we consider it sent.
      setStatus("Email webhook sent (simple POST). Check inbox/spam.", "ok");
      return;
    } catch (e1) {
      console.warn("Email webhook simple POST failed, falling back to no-cors:", e1);
    }

    // 2) Fire-and-forget fallback (no-cors). We cannot read the response, but Apps Script will receive it.
    try {
      await fetch(EMAIL_WEBHOOK_URL, {
        method: "POST",
        mode: "no-cors",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify(payload)
      });
      setStatus("Email sent (no-cors fallback). Check inbox/spam.", "ok");
    } catch (e2) {
      console.error("Email webhook failed:", e2);
      setStatus("Email webhook error: " + (e2.message || String(e2)), "error");
    }
  }

    const POLYGON_CHAIN_ID_HEX = "0x89"; // 137
    const POLYGON_PARAMS = {
      chainId: POLYGON_CHAIN_ID_HEX,
      chainName: "Polygon",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: ["https://polygon-rpc.com","https://rpc.ankr.com/polygon"],
      blockExplorerUrls: ["https://polygonscan.com"]
    };

    // Friendly chain names
    const CHAIN_NAME = {
      1:"Ethereum",137:"Polygon",80002:"Polygon Amoy",10:"OP Mainnet",42161:"Arbitrum One",
      8453:"Base",56:"BNB Smart Chain",43114:"Avalanche C-Chain",324:"zkSync Era",
      11155111:"Sepolia",5:"Goerli (deprecated)"
    };
    const getChainNameFromId = (n,fallback)=> CHAIN_NAME[n] || fallback || `Chain ${n}`;

    const el = id => document.getElementById(id);
    const linkPolygonscan = (p) => `https://polygonscan.com/${p}`;
    const setStatus = (msg, cls="muted") => { const s=el("status"); s.className=cls; s.textContent=msg||""; };

    // --- EIP-6963 discovery (Brave/MM) ---
    const discovered = new Map();
    window.addEventListener("eip6963:announceProvider", (ev) => { discovered.set(ev.detail.info.uuid, ev.detail); });
    window.dispatchEvent(new Event("eip6963:requestProvider"));
    function getAllInjected() {
      const from6963 = [...discovered.values()].map(d => d && d.provider).filter(Boolean);
      const eth = window.ethereum;
      const fromEth = (() => {
        if (!eth) return [];
        if (Array.isArray(eth.providers) && eth.providers.length) return eth.providers.filter(Boolean);
        return [eth];
      })();
      const set = new Set([...from6963, ...fromEth]);
      return [...set];
    }
    function pickProvider(kind="auto"){
      const list = getAllInjected(); if (!list.length) return null;
      const brave6963 = (() => { for (const d of discovered.values()) if (d.info?.rdns==="com.brave.wallet") return d.provider; return null; })();
      const brave = brave6963 || list.find(p=>p.isBraveWallet);
      const metamask = list.find(p=>p.isMetaMask && !p.isBraveWallet);
      if (kind==="brave") return brave ?? (list.length===1?list[0]:null);
      if (kind==="metamask") return metamask ?? null;
      return brave ?? metamask ?? list[0];
    }
    function attachProviderEvents(injected){
      if (!injected || injected.__hasHandlers) return;
      injected.__hasHandlers = true;
      injected.on?.("accountsChanged", () => connect(localStorage.getItem("walletPref") || "auto"));
      injected.on?.("chainChanged",   () => connect(localStorage.getItem("walletPref") || "auto"));
      injected.on?.("disconnect",     () => { setStatus("Wallet disconnected.", "error"); el("address").textContent="Not connected"; disableMint(true); });
    }

    let provider, signer, contract, ownerAddr, myAddr, currentInjected = null;
    let CONTRACT_ADDRESS;
    let currentPriceWei = 0n; // per mint

    // Helpers
    function normalizeAddress(s){ try { return ethers.getAddress(s.trim()); } catch { return null; } }
    function parseAddresses(text){
      return text.split(/[\s,]+/g).map(s=>s.trim()).filter(Boolean).map(normalizeAddress).filter(Boolean);
    }
    function formatMatic(wei){ try { return `${ethers.formatEther(wei)} MATIC`; } catch { return `${wei.toString()} wei`; } }
    function formatUsdCents(c){ try{ const n = BigInt(c); const d = (n/100n).toString(); const r = (n%100n).toString().padStart(2,"0"); return `$${d}.${r}`; } catch { return `$${c}`; } }
    function shippingHashFromInput(){
      const s = el("shipping").value.trim();
      if (!s) return "0x" + "00".repeat(32); // bytes32 zero if none
      return ethers.id(s); // keccak256(utf8)
    }
    const disableMint = (disabled)=>{ el("mintBtn").disabled = !!disabled; el("mintMeBtn").disabled = !!disabled; };

    async function connect(kind="auto"){
      const injected = pickProvider(kind);
      if (!injected){ setStatus("No wallet detected. In Brave, enable Brave Wallet (brave://settings/wallet).", "error"); return; }
      currentInjected = injected;
      attachProviderEvents(injected);

      try{
        await injected.request({ method:"eth_requestAccounts" });
        provider = new ethers.BrowserProvider(injected);
        signer = await provider.getSigner();
        myAddr = await signer.getAddress();
        el("address").textContent = `${myAddr.slice(0,6)}…${myAddr.slice(-4)}`;

        try { CONTRACT_ADDRESS = ethers.getAddress(RAW_CONTRACT_ADDRESS); }
        catch { setStatus("Invalid contract address configured.", "error"); disableMint(true); return; }

        const net = await provider.getNetwork();
        const cid = Number(net.chainId);
        const friendly = getChainNameFromId(cid, net.name);
        el("network").textContent = `${friendly} (${cid})`;

        el("contractLink").textContent = `${CONTRACT_ADDRESS.slice(0,6)}…${CONTRACT_ADDRESS.slice(-4)}`;
        el("contractLink").href = linkPolygonscan(`address/${CONTRACT_ADDRESS}`);

        if (cid !== 137){
          el("switchBtn").style.display = "inline-block";
          setStatus("Wrong network. Click “Switch to Polygon”.", "error");
          disableMint(true); return;
        }
        el("switchBtn").style.display = "none";

        contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

        // Owner gate
        ownerAddr = await contract.owner();
        const isOwner = ownerAddr.toLowerCase() === myAddr.toLowerCase();
        if (!isOwner){
          setStatus("This page is owner-only mint. Your wallet is not the owner.", "error");
          disableMint(true);
        } else {
          setStatus("");
          disableMint(false);
          if (!el("to").value.trim()) el("to").value = myAddr;
        }

        await refreshReads();
      }catch(err){
        console.error(err);
        setStatus(err?.shortMessage || err?.message || String(err), "error");
        disableMint(true);
      }
    }

    async function switchToPolygon(){
      const injected = currentInjected || pickProvider("auto");
      if (!injected) return setStatus("No wallet available to switch.", "error");
      try{
        await injected.request({ method:"wallet_switchEthereumChain", params:[{ chainId: POLYGON_CHAIN_ID_HEX }] });
      }catch(err){
        if (err && err.code === 4902){
          await injected.request({ method:"wallet_addEthereumChain", params:[POLYGON_PARAMS] });
        } else { setStatus(err?.message || "Network switch failed.", "error"); return; }
      }
      await connect(localStorage.getItem("walletPref") || "auto");
    }

    async function refreshReads(){
      if (!contract) return;
      try{
        const [minted, max, remaining, name, symbol, priceWei, priceCents, _claimOpen, _deliveryOpen] = await Promise.all([
          contract.totalMinted(),
          contract.MAX_SUPPLY(),
          contract.remaining(),
          contract.name(),
          contract.symbol(),
          contract.requiredWei(),
          contract.mintPriceUsdCents(),
          contract.claimOpen(),
          contract.deliveryUpdatesOpen()
        ]);
        el("supply").textContent = BigInt(minted).toString();
        el("max").textContent = BigInt(max).toString();
        el("left").textContent = BigInt(remaining).toString();
        el("ns").textContent = `${name} / ${symbol}`;

        currentPriceWei = BigInt(priceWei.toString());
        el("priceMatic").textContent = formatMatic(currentPriceWei);
        el("priceUsd").textContent = formatUsdCents(priceCents);

        el("claimOpen").textContent = _claimOpen ? "true" : "false";
        el("deliveryOpen").textContent = _deliveryOpen ? "true" : "false";
      }catch(e){
        console.warn("read error", e);
      }
    }

    async function mintOne(to, claimNow, shippingHash){
      const overrides = currentPriceWei > 0n ? { value: currentPriceWei } : {};
      return contract.mintFor(to, !!claimNow, shippingHash, overrides);
    }

    async function mintToMe(){
      if (!contract || !myAddr) return;
      try{
        const me = normalizeAddress(myAddr); if (!me) return setStatus("Invalid sender address.", "error");

        const claimNow = !!el("claimNow").checked;
        const shippingHash = claimNow ? shippingHashFromInput() : ("0x" + "00".repeat(32));

        setStatus("Sending tx…");
        disableMint(true);
        const tx = await mintOne(me, claimNow, shippingHash);
        setStatus("Mining…");
        const receipt = await tx.wait();
        setStatus("✅ Confirmed", "ok");

        // --- EMAIL: send details after success ---
        const shippingText = claimNow ? el("shipping").value.trim() : "";
        await sendClaimEmail({
          wallet: myAddr,
          tokenId: "(unknown)", // simple; can be parsed from logs later if you want
          txHash: receipt.hash,
          claimNow,
          shippingText,
          shippingHash
        });

        const a = document.createElement("a");
        a.href = linkPolygonscan(`tx/${receipt.hash}`); a.target = "_blank"; a.rel = "noreferrer"; a.textContent = `Tx: ${receipt.hash.slice(0,10)}…`;
        el("link").prepend(a);
        await refreshReads();
      }catch(err){
        console.error(err);
        const m = (err?.shortMessage || err?.message || String(err)).toLowerCase();
        if (err?.code === 4001) setStatus("User rejected the transaction.", "error");
        else if (m.includes("insufficient funds")) setStatus("Insufficient funds for price + gas.", "error");
        else setStatus("❌ " + (err?.shortMessage || err?.message || String(err)), "error");
      }finally{
        disableMint(false);
      }
    }

    async function mintTo(){
      if (!contract) return;
      const list = parseAddresses(el("to").value);
      if (!list.length) return setStatus("Enter at least one valid recipient address.", "error");

      const claimNow = !!el("claimNow").checked;
      const shippingHash = claimNow ? shippingHashFromInput() : ("0x" + "00".repeat(32));
      if (claimNow && list.length > 1){
        return setStatus("Claim-now at mint is only allowed for a single recipient at once (provide one address).", "error");
      }

      try{
        disableMint(true);
        let i = 0;
        for (const addr of list){
          setStatus(`Sending tx ${i+1}/${list.length}…`);
          const tx = await mintOne(addr, claimNow, shippingHash);
          setStatus(`Mining ${i+1}/${list.length}…`);
          const receipt = await tx.wait();

          // --- EMAIL per tx ---
          const shippingText = claimNow ? el("shipping").value.trim() : "";
          await sendClaimEmail({
            wallet: addr,
            tokenId: "(unknown)",
            txHash: receipt.hash,
            claimNow,
            shippingText,
            shippingHash
          });

          const a = document.createElement("a");
          a.href = linkPolygonscan(`tx/${receipt.hash}`); a.target = "_blank"; a.rel = "noreferrer"; a.textContent = `Tx ${i+1}: ${receipt.hash.slice(0,10)}…`;
          el("link").prepend(a);
          i++;
        }
        setStatus("✅ All mints confirmed", "ok");
        await refreshReads();
      }catch(err){
        console.error(err);
        const m = (err?.shortMessage || err?.message || String(err)).toLowerCase();
        if (err?.code === 4001) setStatus("User rejected a transaction.", "error");
        else if (m.includes("insufficient funds")) setStatus("Insufficient funds for price + gas.", "error");
        else setStatus("❌ " + (err?.shortMessage || err?.message || String(err)), "error");
      }finally{
        disableMint(false);
      }
    }

    // Owner tools
    async function checkStatus(){
      const id = BigInt(el("checkId").value || "0");
      if (id <= 0n) { setStatus("Enter a valid tokenId.", "error"); return; }
      try{
        const [c,d] = await Promise.all([
          contract.physicalClaimed(id),
          contract.physicalDelivered(id)
        ]);
        el("claimedOut").textContent = c ? "true" : "false";
        el("deliveredOut").textContent = d ? "true" : "false";
        setStatus("Status fetched.");
      }catch(err){
        console.error(err);
        setStatus(err?.shortMessage || err?.message || String(err), "error");
      }
    }

    async function setDeliveredFlag(toVal){
      const id = BigInt(el("checkId").value || "0");
      if (id <= 0n) { setStatus("Enter a valid tokenId.", "error"); return; }
      try{
        setStatus(`Sending setDelivered(${id.toString()}, ${toVal})…`);
        const tx = await contract.setDelivered(id, !!toVal);
        setStatus("Mining…");
        await tx.wait();
        setStatus("✅ Delivered flag updated", "ok");
        await checkStatus();
      }catch(err){
        console.error(err);
        setStatus(err?.shortMessage || err?.message || String(err), "error");
      }
    }

    // Wire buttons + remember preference
    const remember = (k) => { try { localStorage.setItem("walletPref", k); } catch {} };
    document.getElementById("connectAuto").addEventListener("click", () => { remember("auto"); connect("auto"); });
    document.getElementById("connectBrave").addEventListener("click", () => { remember("brave"); connect("brave"); });
    document.getElementById("connectMM").addEventListener("click", () => { remember("metamask"); connect("metamask"); });
    document.getElementById("switchBtn").addEventListener("click", switchToPolygon);
    document.getElementById("mintMeBtn").addEventListener("click", mintToMe);
    document.getElementById("mintBtn").addEventListener("click", mintTo);

    document.getElementById("btnCheck").addEventListener("click", checkStatus);
    document.getElementById("btnSetDeliveredTrue").addEventListener("click", () => setDeliveredFlag(true));
    document.getElementById("btnSetDeliveredFalse").addEventListener("click", () => setDeliveredFlag(false));

    // Legacy direct connect (fallback)
    document.getElementById("connectLegacy").addEventListener("click", async () => {
      try {
        const eth = window.ethereum;
        if (!eth) { setStatus("No window.ethereum found.", "error"); return; }
        await eth.request({ method: "eth_requestAccounts" });
        provider = new ethers.BrowserProvider(eth);
        signer = await provider.getSigner();
        myAddr = await signer.getAddress();
        el("address").textContent = `${myAddr.slice(0,6)}…${myAddr.slice(-4)}`;

        const net = await provider.getNetwork();
        const cid = Number(net.chainId);
        const friendly = getChainNameFromId(cid, net.name);
        el("network").textContent = `${friendly} (${cid})`;

        if (cid !== 137) {
          el("switchBtn").style.display = "inline-block";
          setStatus("Wrong network. Click “Switch to Polygon”.", "error");
          disableMint(true); return;
        }
        el("switchBtn").style.display = "none";

        CONTRACT_ADDRESS = ethers.getAddress(RAW_CONTRACT_ADDRESS);
        contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

        ownerAddr = await contract.owner();
        const isOwner = ownerAddr.toLowerCase() === myAddr.toLowerCase();
        if (!isOwner){ setStatus("This page is owner-only mint. Your wallet is not the owner.", "error"); disableMint(true); }
        else { setStatus(""); disableMint(false); if (!el("to").value.trim()) el("to").value = myAddr; }

        await refreshReads();
      } catch (err) {
        console.error(err);
        setStatus(err?.shortMessage || err?.message || String(err), "error");
      }
    });

    // Test Email (no mint needed)
    // document.getElementById("testEmail").addEventListener("click", async () => {
    //  await sendClaimEmail({
    //    wallet: myAddr || "0xTEST",
    //    tokenId: "12345",
    //    txHash: "0xdeadbeef",
    //    claimNow: true,
    //    shippingText: "Test shipping payload",
    //    shippingHash: ethers.id("Test shipping payload")
    //  });
    //});

    // Enable/disable delivered buttons based on wallet ownership
    function updateOwnerButtons(){
      const isOwner = ownerAddr && myAddr && ownerAddr.toLowerCase() === myAddr.toLowerCase();
      el("btnSetDeliveredTrue").disabled  = !isOwner;
      el("btnSetDeliveredFalse").disabled = !isOwner;
    }
    const _updateOwnerButtonsInterval = setInterval(updateOwnerButtons, 500);

    // Auto-connect to last chosen wallet
    (function autoConnect() {
      const last = (() => { try { return localStorage.getItem("walletPref") } catch { return null } })();
      setTimeout(() => {
        const hasProviders = getAllInjected().length || discovered.size;
        if (hasProviders && last) connect(last);
      }, 200);
    })();
  </script>
</body>
</html>
