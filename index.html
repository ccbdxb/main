<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NFT Mint (Owner) — Brave & MetaMask</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; background:#0b0c10; color:#eaf5ff; }
    .wrap { max-width: 820px; margin: 40px auto; padding: 24px; background:#11141a; border:1px solid #222936; border-radius:16px; }
    h1 { margin:0 0 8px; }
    .row { display:flex; justify-content:space-between; padding:10px 12px; background:#0e1218; border:1px solid #1d2431; border-radius:10px; margin-top:10px; }
    .stack{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button{ cursor:pointer; padding:10px 14px; border-radius:10px; border:1px solid #2a3344; background:#1f2837; color:#eaf5ff; }
    button[disabled]{ opacity:.6; cursor:not-allowed; }
    input[type=text], textarea{ width:100%; padding:10px 12px; border-radius:10px; border:1px solid #2a3344; background:#0e1218; color:#eaf5ff; }
    a{ color:#8ab4ff; }
    .muted{ opacity:.8 }
    .error{ color:#ff6b6b }
    .ok{ color:#6bff95 }
    .pill{ font-size:12px; padding:4px 8px; border-radius:999px; background:#1b2230; border:1px solid #2a3344; }
    .kvs{ display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .kvs span{ font-size:12px; opacity:.85; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js" defer></script>
</head>
<body>
  <div class="wrap">
    <h1>Owner Mint</h1>
    <div class="kvs">
      <span>Network: <strong id="network">—</strong></span>
      <span>Contract: <a id="contractLink" href="#" target="_blank" rel="noreferrer">—</a></span>
      <span>Name/Symbol: <strong id="ns">—</strong></span>
    </div>

    <!-- Wallet controls -->
    <div class="stack" style="margin:12px 0 16px;">
      <button id="connectAuto">Connect (Auto)</button>
      <button id="connectBrave">Connect with Brave</button>
      <button id="connectMM">Connect with MetaMask</button>
      <button id="switchBtn" style="display:none;">Switch to Polygon</button>
      <span id="address" class="pill">Not connected</span>
    </div>

    <div class="row"><span>Supply</span><strong><span id="supply">—</span>/<span id="max">—</span> (<span id="left">—</span> left)</strong></div>
    <div class="row"><span>Price</span><strong>Free (owner only)</strong></div>

    <div class="row" style="flex-direction:column; align-items:stretch;">
      <div class="muted" style="margin-bottom:8px;">Recipient address (single) or multiple (comma, space, or newline-separated)</div>
      <textarea id="to" rows="3" placeholder="0x... or paste addr1, addr2, addr3..."></textarea>
      <div class="stack" style="margin-top:10px;">
        <button id="mintMeBtn" disabled>Mint to me</button>
        <button id="mintBtn" disabled>Mint to address(es)</button>
      </div>
    </div>

    <p id="status" class="muted" style="min-height:22px; margin-top:14px;"></p>
    <p id="link" style="min-height:22px;"></p>
  </div>

  <script defer>
    // ====== CONTRACT ======
    const RAW_CONTRACT_ADDRESS = "0x20e28b37f331c9d94f1685f5fa1d1fc6d59d69b6"; // your test contract
    const ABI = [
      {"type":"function","name":"totalMinted","stateMutability":"view","inputs":[],"outputs":[{"type":"uint256"}]},
      {"type":"function","name":"MAX_SUPPLY","stateMutability":"view","inputs":[],"outputs":[{"type":"uint256"}]},
      {"type":"function","name":"owner","stateMutability":"view","inputs":[],"outputs":[{"type":"address"}]},
      {"type":"function","name":"mint","stateMutability":"nonpayable","inputs":[{"name":"to","type":"address"}],"outputs":[]},
      {"type":"function","name":"mintBatch","stateMutability":"nonpayable","inputs":[{"name":"tos","type":"address[]"}],"outputs":[]},
      {"type":"function","name":"name","stateMutability":"view","inputs":[],"outputs":[{"type":"string"}]},
      {"type":"function","name":"symbol","stateMutability":"view","inputs":[],"outputs":[{"type":"string"}]}
    ];
    // =======================

    const POLYGON_CHAIN_ID_HEX = "0x89"; // 137
    const POLYGON_PARAMS = {
      chainId: POLYGON_CHAIN_ID_HEX,
      chainName: "Polygon",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: ["https://polygon-rpc.com","https://rpc.ankr.com/polygon"],
      blockExplorerUrls: ["https://polygonscan.com"]
    };

    const el = id => document.getElementById(id);
    function setStatus(msg, cls="muted"){ const s=el("status"); s.className=cls; s.textContent=msg||""; }
    function linkPolygonscan(path){ return `https://polygonscan.com/${path}`; }

    // --- EIP-6963 discovery ---
    const discovered = new Map();
    window.addEventListener("eip6963:announceProvider", (ev) => {
      const d = ev.detail; discovered.set(d.info.uuid, d);
    });
    window.dispatchEvent(new Event("eip6963:requestProvider"));

    function getAllInjected() {
      if (discovered.size) return [...discovered.values()].map(d => d.provider);
      const eth = window.ethereum;
      if (!eth) return [];
      if (Array.isArray(eth.providers) && eth.providers.length) return eth.providers;
      return [eth];
    }
    function pickProvider(kind = "auto") {
      const list = getAllInjected();
      if (!list.length) return null;

      const brave6963 = (() => {
        for (const d of discovered.values()) if (d.info.rdns === "com.brave.wallet") return d.provider;
        return null;
      })();
      const brave = brave6963 || list.find(p => p.isBraveWallet);
      const metamask = list.find(p => p.isMetaMask && !p.isBraveWallet);

      if (kind === "brave") return brave ?? (list.length === 1 ? list[0] : null);
      if (kind === "metamask") return metamask ?? null;
      return brave ?? metamask ?? list[0];
    }

    function attachProviderEvents(injected) {
      if (!injected || injected.__hasHandlers) return;
      injected.__hasHandlers = true;
      injected.on?.("accountsChanged", () => connect(localStorage.getItem("walletPref") || "auto"));
      injected.on?.("chainChanged", () => connect(localStorage.getItem("walletPref") || "auto"));
      injected.on?.("disconnect", () => {
        setStatus("Wallet disconnected.", "error");
        el("address").textContent = "Not connected";
        disableMint(true);
      });
    }

    let provider, signer, contract, ownerAddr, myAddr, currentInjected = null;
    let CONTRACT_ADDRESS;

    // ---- Address helpers ----
    function normalizeAddress(s){
      try { return ethers.getAddress(s.trim()); } catch { return null; }
    }
    function parseAddresses(text){
      // split on comma, whitespace, or newline; drop empties; checksum-validate
      return text
        .split(/[\s,]+/g)
        .map(s=>s.trim())
        .filter(Boolean)
        .map(normalizeAddress)
        .filter(Boolean);
    }

    function disableMint(disabled){
      el("mintBtn").disabled = !!disabled;
      el("mintMeBtn").disabled = !!disabled;
    }

    async function connect(kind = "auto"){
      const injected = pickProvider(kind);
      if (!injected){
        setStatus("No wallet detected. In Brave, enable Brave Wallet (brave://settings/wallet).", "error");
        return;
      }
      currentInjected = injected;
      attachProviderEvents(injected);

      try{
        await injected.request({ method:"eth_requestAccounts" });
        provider = new ethers.BrowserProvider(injected);
        signer = await provider.getSigner();
        myAddr = await signer.getAddress();
        el("address").textContent = `${myAddr.slice(0,6)}…${myAddr.slice(-4)}`;

        // Normalize contract address to checksum early (prevents subtle issues)
        try {
          CONTRACT_ADDRESS = ethers.getAddress(RAW_CONTRACT_ADDRESS);
        } catch {
          setStatus("Invalid contract address configured.", "error");
          disableMint(true);
          return;
        }

        const net = await provider.getNetwork();
        el("network").textContent = `${net.name} (${Number(net.chainId)})`;
        el("contractLink").textContent = `${CONTRACT_ADDRESS.slice(0,6)}…${CONTRACT_ADDRESS.slice(-4)}`;
        el("contractLink").href = linkPolygonscan(`address/${CONTRACT_ADDRESS}`);

        if (Number(net.chainId) !== 137){
          el("switchBtn").style.display = "inline-block";
          setStatus("Wrong network. Click “Switch to Polygon”.", "error");
          disableMint(true);
          return;
        }

        el("switchBtn").style.display = "none";
        contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

        // Owner gate
        ownerAddr = await contract.owner();
        const isOwner = ownerAddr.toLowerCase() === myAddr.toLowerCase();
        if (!isOwner){
          setStatus("This contract is owner-only mint. Your wallet is not the owner.", "error");
          disableMint(true);
        } else {
          setStatus("");
          disableMint(false);
          // only autofill if empty (so we don't clobber pasted lists)
          if (!el("to").value.trim()) el("to").value = myAddr;
        }

        await refreshReads();

        // Optional: live update supply on Transfer events (comment out if your RPC doesn't support logs)
        // provider.on({ address: CONTRACT_ADDRESS, topics: [ethers.id("Transfer(address,address,uint256)")] }, refreshReads);
      }catch(err){
        console.error(err);
        const msg = (err && (err.shortMessage || err.message)) || String(err);
        setStatus(msg, "error");
        disableMint(true);
      }
    }

    async function switchToPolygon(){
      const injected = currentInjected || pickProvider("auto");
      if (!injected) return setStatus("No wallet available to switch.", "error");

      try{
        await injected.request({ method:"wallet_switchEthereumChain", params:[{ chainId: POLYGON_CHAIN_ID_HEX }] });
      }catch(err){
        if (err && err.code === 4902){
          await injected.request({ method:"wallet_addEthereumChain", params:[POLYGON_PARAMS] });
        } else {
          // user rejected or other error
          setStatus(err?.message || "Network switch failed.", "error");
          return;
        }
      }
      await connect(localStorage.getItem("walletPref") || "auto");
    }

    async function refreshReads(){
      if (!contract) return;
      try{
        const [minted, max, name, symbol] = await Promise.all([
          contract.totalMinted(),
          contract.MAX_SUPPLY(),
          contract.name(),
          contract.symbol()
        ]);
        const sMinted = BigInt(minted).toString();
        const sMax = BigInt(max).toString();
        el("supply").textContent = sMinted;
        el("max").textContent = sMax;
        el("left").textContent = (BigInt(max) - BigInt(minted)).toString();
        el("ns").textContent = `${name} / ${symbol}`;
      }catch(e){
        console.warn("read error", e);
      }
    }

    async function mintToMe(){
      if (!contract || !myAddr) return;
      try{
        const me = normalizeAddress(myAddr);
        if (!me) return setStatus("Invalid sender address.", "error");

        setStatus("Sending tx…");
        disableMint(true);
        const tx = await contract.mint(me);
        setStatus("Mining…");
        const receipt = await tx.wait();
        setStatus("✅ Confirmed", "ok");
        el("link").innerHTML = `<a href="${linkPolygonscan(`tx/${receipt.hash}`)}" target="_blank" rel="noreferrer">View on Polygonscan</a>`;
        await refreshReads();
      }catch(err){
        console.error(err);
        if (err?.code === 4001) setStatus("User rejected the transaction.", "error");
        else setStatus("❌ " + (err?.shortMessage || err?.message || String(err)), "error");
      }finally{
        disableMint(false);
      }
    }

    async function mintTo(){
      if (!contract) return;
      const list = parseAddresses(el("to").value);
      if (!list.length) return setStatus("Enter at least one valid recipient address.", "error");
      try{
        setStatus("Sending tx…");
        disableMint(true);
        let tx;
        if (list.length === 1){
          tx = await contract.mint(list[0]);
        } else {
          if (list.length > 100) return setStatus("Batch too large. Try 100 or fewer.", "error");
          tx = await contract.mintBatch(list);
        }
        setStatus("Mining…");
        const receipt = await tx.wait();
        setStatus("✅ Confirmed", "ok");
        el("link").innerHTML = `<a href="${linkPolygonscan(`tx/${receipt.hash}`)}" target="_blank" rel="noreferrer">View on Polygonscan</a>`;
        await refreshReads();
      }catch(err){
        console.error(err);
        if (err?.code === 4001) setStatus("User rejected the transaction.", "error");
        else setStatus("❌ " + (err?.shortMessage || err?.message || String(err)), "error");
      }finally{
        disableMint(false);
      }
    }

    // Wire buttons + remember preference
    const remember = (k) => { try { localStorage.setItem("walletPref", k); } catch {} };
    document.getElementById("connectAuto").addEventListener("click", () => { remember("auto"); connect("auto"); });
    document.getElementById("connectBrave").addEventListener("click", () => { remember("brave"); connect("brave"); });
    document.getElementById("connectMM").addEventListener("click", () => { remember("metamask"); connect("metamask"); });
    document.getElementById("switchBtn").addEventListener("click", switchToPolygon);
    document.getElementById("mintMeBtn").addEventListener("click", mintToMe);
    document.getElementById("mintBtn").addEventListener("click", mintTo);

    // Auto-connect to last chosen wallet after a tiny delay
    (function autoConnect() {
      const last = (() => { try { return localStorage.getItem("walletPref") } catch { return null } })();
      setTimeout(() => {
        const hasProviders = getAllInjected().length || discovered.size;
        if (hasProviders && last) connect(last);
      }, 200);
    })();
  </script>
</body>
</html>
